import requests
import subprocess
from bs4 import BeautifulSoup
import re

# Base URLs for DVWA vulnerabilities
base_url_stored = 'http://127.0.0.1/vulnerabilities/xss_s/'
base_url_reflected = 'http://127.0.0.1/vulnerabilities/xss_r/'
cookies = {
    'PHPSESSID': 'e4lpasml78avcva4t7uj8h79d4',  # Replace with your actual session cookie
    'security': 'low'  # Adjust this based on the security level for Stored XSS
}

# List of XSS payloads to test
stored_payloads = [
    "<script>alert('Stored XSS')</script>"
]

reflected_payloads = [
    "<img src=x onerror=alert('Reflected XSS')>",
    "<button onclick=\"alert('Reflected XSS')\">Click me</button>"
]

def submit_stored_xss_payloads(base_url, payloads):
    """Submit payloads to the web application and display results for Stored XSS."""
    print("\nTesting Stored XSS Payloads...\n")
    for payload in payloads:
        data = {
            'txtName': payload,
            'mtxMessage': payload,
            'btnSign': 'Sign'
        }
        try:
            # Submit the payload
            response = requests.post(base_url, cookies=cookies, data=data, timeout=10)
            response.raise_for_status()

            # Fetch the page where the stored payload should appear
            response = requests.get(base_url, cookies=cookies, timeout=10)
            response.raise_for_status()

            # Extract and display relevant data from the response
            print(f"Response after submitting payload '{payload}':")
            extract_and_display_data(response, payload)

            # Check if payload is reflected in the response text
            payload_found = payload in response.text
            
            # Check if payload is in any script tag
            soup = BeautifulSoup(response.text, 'html.parser')
            script_tags = soup.find_all('script')
            for script in script_tags:
                if script.string and payload in script.string:
                    payload_found = True
                    break

            # Display the result
            if payload_found:
                print(f"Stored XSS successful with payload: {payload}")
            else:
                print(f"Stored XSS unsuccessful with payload: {payload}")

            print("-" * 50)

        except requests.exceptions.RequestException as e:
            print(f"Error: {e}")


def test_reflected_xss_payloads(base_url, payloads):
    """Submit XSS payloads and check for successful reflection."""
    print("\nTesting Reflected XSS Payloads...\n")
    for payload in payloads:
        try:
            response = requests.get(base_url, cookies=cookies, params={'name': payload}, timeout=10)
            response.raise_for_status()

            # Extract and display relevant data from the response
            print(f"Response after submitting payload '{payload}':")
            extract_and_display_data(response, payload)

            # Check for reflected payloads
            if payload in response.text:
                print(f"Reflected XSS successful with payload: {payload}")
            else:
                # Check if payload is present in any script tag
                soup = BeautifulSoup(response.text, 'html.parser')
                scripts = soup.find_all('script')
                payload_found = any(script.string and payload in script.string for script in scripts)
                if payload_found:
                    print(f"Reflected XSS successful with payload: {payload}")
                else:
                    print(f"Reflected XSS unsuccessful with payload: {payload}")

            print("-" * 50)

        except requests.exceptions.RequestException as e:
            print(f"Error testing payload {payload}: {e}")

def extract_and_display_data(response, payload):
    """Extract and display relevant data from the HTTP response to analyze XSS payload results."""
    print("\nExtracting data from response...")
    # Print response status code
    print(f"Status Code: {response.status_code}")

    # Print a message indicating that the response snippet is not displayed
    print("Response snippet is not displayed to avoid printing HTML code.")

    # Search for the payload in the response and print specific lines
    matches = list(re.finditer(re.escape(payload), response.text, re.IGNORECASE))
    if matches:
        for match in matches:
            start = max(0, match.start() - 30)
            end = min(len(response.text), match.end() + 30)
            context = response.text[start:end]
            print(f"Payload detected in response:\n{context}")
            print(f"Match position: {match.start()} to {match.end()}")
    else:
        print("No XSS payload detected in response.")

def get_container_id():
    """Retrieve the container ID for the running DVWA container."""
    try:
        result = subprocess.run(
            ["docker", "ps", "--filter", "ancestor=vulnerables/web-dvwa", "--format", "{{.ID}}"],
            capture_output=True,
            text=True
        )
        container_id = result.stdout.strip()
        if not container_id:
            raise ValueError("No DVWA container found.")
        return container_id
    except Exception as e:
        print(f"Error retrieving container ID: {e}")
        return None

def list_php_files(directory):
    """List all PHP files in a given directory inside the Docker container."""
    try:
        container_id = get_container_id()
        if not container_id:
            print("Unable to retrieve container ID.")
            return []

        result = subprocess.run(
            ["docker", "exec", container_id, "find", directory, "-type", "f", "-name", "*.php"],
            capture_output=True,
            text=True
        )
        files = result.stdout.strip().split('\n')
        return files
    except Exception as e:
        print(f"Error listing PHP files: {e}")
        return []

def fetch_php_code(file_path):
    """Fetch and return the PHP code from the Docker container."""
    try:
        container_id = get_container_id()
        if not container_id:
            print("Unable to retrieve container ID.")
            return ""

        result = subprocess.run(
            ["docker", "exec", container_id, "cat", file_path],
            capture_output=True,
            text=True
        )
        return result.stdout
    except Exception as e:
        print(f"Error fetching PHP code: {e}")
        return ""

def extract_vulnerable_code(php_code, security_level):
    """Extract and return all lines containing vulnerable code snippets."""
    lines = php_code.splitlines()
    vulnerable_lines = []

    # Define patterns to identify potential vulnerabilities
    patterns = {
        'user_input': r'\$_POST\[\s*\'[^\']*\'\s*\]|\$_GET\[\s*\'[^\']*\'\s*\]',  # Detect usage of user input
        'direct_output': r'echo\s*\$\w+|print\s*\$\w+',  # Detect direct output of user input
        'escaping_functions': r'(mysqli_real_escape_string|htmlspecialchars|addslashes|strip_tags)\s*\(',  # Detect escaping functions
        'csrf_token': r'checkToken\(\s*\$_REQUEST\[\s*\'user_token\'\s*\],\s*\$_SESSION\[\s*\'session_token\'\s*\]'  # Detect anti-CSRF token usage
    }

    try:
        # Check if anti-CSRF token is present in the code
        csrf_token_found = any(re.search(patterns['csrf_token'], line) for line in lines)
        
        # Check each line against patterns
        for i, line in enumerate(lines):
            if re.search(patterns['user_input'], line):
                # Check if proper mitigation is present
                if not any(re.search(pattern, line) for pattern in [patterns['escaping_functions']]):
                    # Check previous lines for escaping functions or CSRF token
                    for prev_line in lines[max(0, i-5):i]:
                        if re.search(patterns['escaping_functions'], prev_line) or csrf_token_found:
                            break
                    else:
                        if security_level in ['low', 'medium']:  # For low and medium security levels
                            vulnerable_lines.append(f"Line {i + 1}: {line.strip()} - Reason: Direct output of user input without proper escaping or validation.")
                        elif security_level == 'high':  # For high security level, check if sanitization is present
                            if not any(re.search(patterns['escaping_functions'], prev_line) for prev_line in lines[max(0, i-5):i]):
                                vulnerable_lines.append(f"Line {i + 1}: {line.strip()} - Reason: Direct output of user input without proper escaping or validation.")
    except re.error as e:
        print(f"Regex error: {e}")

    return vulnerable_lines

def main():
    # Print the security level and target URLs at the top
    security_level = cookies.get('security')
    print(f"Security Level: {security_level}")

    # Test Stored XSS Payloads
    print(f"\n--- Testing Stored XSS Payloads on URL: {base_url_stored} ---\n")
    submit_stored_xss_payloads(base_url_stored, stored_payloads)

    # Test Reflected XSS Payloads
    print(f"\n--- Testing Reflected XSS Payloads on URL: {base_url_reflected} ---\n")
    test_reflected_xss_payloads(base_url_reflected, reflected_payloads)

    # List PHP files and check for vulnerabilities
    php_files_stored = list_php_files('/var/www/html/vulnerabilities/xss_s/')
    php_files_reflected = list_php_files('/var/www/html/vulnerabilities/xss_r/')

    print(f"\n--- PHP Files in Stored XSS Directory ---")
    for php_file in php_files_stored:
        print(f"Processing: {php_file}")
        php_code = fetch_php_code(php_file)
        vulnerable_code = extract_vulnerable_code(php_code, security_level)
        for line in vulnerable_code:
            print(line)

    print(f"\n--- PHP Files in Reflected XSS Directory ---")
    for php_file in php_files_reflected:
        print(f"Processing: {php_file}")
        php_code = fetch_php_code(php_file)
        vulnerable_code = extract_vulnerable_code(php_code, security_level)
        for line in vulnerable_code:
            print(line)

if __name__ == "__main__":
    main()
